================================================================================
                                ISA REFERENCE
================================================================================
Data Width: 15 bits
Address Space: 7 bits (0 to 127)
Registers: R0 to R15


================================================================================
 PROGRAM 1: SIEVE OF ERATOSTHENES (Prime Filter)
 Description: Finds prime numbers up to 31.
================================================================================

-- 1. INITIALIZATION
0:  CLR R8          -- Clear R8
1:  ADDI R8, 31     -- R8 = 31 (Set Mask/Limit)
2:  CLR R1          -- Clear R1
3:  ADDI R1, 1      -- R1 = 1 (Start counter)

-- LOOP INIT (Fill RAM 1..31)
4:  SW R1, R1       -- RAM[R1] = R1
5:  ADDI R1, 1      -- Increment R1
6:  MOV R7, R1      -- Temp check
7:  OR R7, R8       -- Mask check
8:  SUB R7, R8      -- Compare against 31
9:  BLS -5          -- If <= 31, loop to addr 4
10: NOP

-- 2. FILTERS
11: CLR R0          -- R0 = 0 (Eraser)

-- FILTER 2
12: CLR R2          -- Clear R2
13: ADDI R2, 4      -- Start at 4

-- LOOP CHECK 2
14: MOV R7, R2      -- Move R2 to Temp
15: OR R7, R8       -- Mask
16: SUB R7, R8      -- Compare
17: BLS +4          -- If valid, jump to ERASE (addr 21)
18: NOP
19: JMP 25          -- Else, jump to Filter 3
20: NOP

-- ERASE 2
21: SW R2, R0       -- RAM[R2] = 0
22: ADDI R2, 2      -- Next multiple of 2
23: JMP 14          -- Jump to Check
24: NOP

-- FILTER 3
25: CLR R2          -- Clear R2
26: ADDI R2, 6      -- Start at 6

-- LOOP CHECK 3
27: MOV R7, R2
28: OR R7, R8
29: SUB R7, R8
30: BLS +4          -- If valid, jump to ERASE (addr 34)
31: NOP
32: JMP 38          -- Else, jump to Filter 5
33: NOP

-- ERASE 3
34: SW R2, R0       -- RAM[R2] = 0
35: ADDI R2, 3      -- Next multiple of 3
36: JMP 27          -- Jump to Check
37: NOP

-- FILTER 5
38: CLR R2          -- Clear R2
39: ADDI R2, 10     -- Start at 10

-- LOOP CHECK 5
40: MOV R7, R2
41: OR R7, R8
42: SUB R7, R8
43: BLS +4          -- If valid, jump to ERASE (addr 47)
44: NOP
45: JMP 51          -- Else, jump to READ PHASE
46: NOP

-- ERASE 5
47: SW R2, R0       -- RAM[R2] = 0
48: ADDI R2, 5      -- Next multiple of 5
49: JMP 40          -- Jump to Check
50: NOP

-- 3. READ AND DISPLAY
51: CLR R1          -- Clear Pointer
52: ADDI R1, 2      -- Start reading at 2

-- READ LOOP
53: LW R4, R1       -- Load RAM[R1] to R4
54: NOP
55: MOV R6, R4      -- Display on R6
56: ADDI R1, 1      -- Increment Pointer
57: MOV R7, R1
58: OR R7, R8
59: SUB R7, R8      -- Check Limit
60: BLS -7          -- Loop back to addr 53
61: NOP

-- 4. FINAL TRAP TEST
62: CLR R1          -- Clear R1
63: 1111...         -- INVALID OPCODE (Intentional Break/Halt)

-- UNREACHABLE CODE (Unless PC skips 63)
64: ADDI R1, 1      -- Increment R1
65: JMP 65          -- Infinite Loop (Trap) on address 65
66: NOP


================================================================================
 PROGRAM 2: INSTRUCTION VALIDATION TEST
 Description: Tests all opcodes (ALU, Logic, Memory, Branches).
================================================================================

--- 1. ARITHMETIC INITIALIZATION
0:  CLR R1          -- Clear R1
1:  ADDI R1, 10     -- R1 = 10
2:  CLR R2          -- Clear R2
3:  ADDI R2, 5      -- R2 = 5
4:  CLR R3          -- Clear R3

-- 2. ADDITION TEST
5:  ADD R3, R1      -- R3 = 0 + 10 = 10
6:  ADD R3, R2      -- R3 = 10 + 5 = 15
7:  MOV R4, R3      -- R4 = 15 (Copy result to R4)

-- 3. SUBTRACTION & BRANCH LOWER SAME (BLS) TEST
8:  CLR R5          -- Clear R5
9:  SUB R5, R3      -- R5 = 0 - 15 = -15 (Triggers Borrow/Carry & Negative Flag)
10: BLS +2          -- Branch if Lower/Same (Offset +2 -> Target 12)
11: JMP 1           -- TRAP: If BLS fails, jump to 1 (Infinite error loop)

-- 4. MEMORY TEST (Store Word / Load Word)
12: CLR R5          -- Clear R5 (Target of BLS). Sets Address = 0.
13: SW R5, R4       -- RAM[R5] = R4 (Store 15 at Address 0)
14: CLR R6          -- Clear R6 (Destination for Load)
15: LW R6, R5       -- R6 = RAM[R5] (Load 15 from Address 0)

-- 5. LOGIC (OR) TEST
16: CLR R7          -- Clear R7
17: ADDI R7, 1      -- R7 = 1
18: OR R7, R6       -- R7 = 1 OR 15 = 15 (0001 OR 1111 = 1111)

-- 6. BRANCH POSITIVE (BPL) TEST
19: CLR R8          -- Clear R8
20: ADDI R8, 20     -- R8 = 20
21: SUB R8, R7      -- R8 = 20 - 15 = 5 (Result is Positive)
22: BPL +2          -- Branch if Positive (Offset +2 -> Target 24)
23: JMP 1           -- TRAP: If BPL fails, jump to 1

-- 7. SUCCESS / HALT
24: CLR R9          -- Clear R9 (Success Indicator reached)
25: JMP 25          -- HALT: Infinite loop at end of program

-- UNREACHABLE / PADDING
26: 1111...         -- Invalid Opcode (Padding)
27: ADDI...         -- Unreachable instruction