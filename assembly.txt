================================================================================
                                ISA REFERENCE
================================================================================
Data Width: 15 bits
Address Space: 7 bits (0 to 127)
Registers: R0 to R15


================================================================================
 PROGRAM 1: SIEVE OF ERATOSTHENES (Prime Filter)
 Description: Finds prime numbers up to 31.
================================================================================

-- PHASE 1: INITIALIZATION
0:  CLR R8          -- Clear R8
1:  ADDI R8, 31     -- R8 = 31 (Set Limit/Mask for modulo check)
2:  CLR R1          -- Clear R1
3:  ADDI R1, 1      -- R1 = 1 (Start counter)

-- LOOP_INIT: Fills RAM[1..31] with values 1..31
4:  SW R1, R1       -- Store val R1 at addr R1 (RAM[R1] = R1)
5:  ADDI R1, 1      -- Increment R1
6:  MOV R7, R1      -- Copy R1 to Temp R7
7:  OR R7, R8       -- Check Mask: (R1 OR 31)
8:  SUB R7, R8      -- Check Limit: (Result - 31)
9:  BLS -5          -- If R1 <= 31, loop back to addr 4
10: NOP             -- Delay slot / Safe space

-- PHASE 2: FILTERING (Removing multiples)
11: CLR R0          -- R0 = 0 (Value used to clear non-primes)

-- FILTER 2 (Remove multiples of 2)
12: CLR R2          -- Clear R2
13: ADDI R2, 4      -- R2 = 4 (Start at 2*2)

-- LOOP_CHECK_2
14: MOV R7, R2      -- Move iterator to temp
15: OR R7, R8       -- Check against limit 31
16: SUB R7, R8      -- Compare
17: BLS +4          -- If R2 <= 31, jump to ERASE (addr 21)
18: NOP
19: JMP 25          -- Else, jump to Next Filter (Filter 3)
20: NOP

-- ERASE_2
21: SW R2, R0       -- RAM[R2] = R0 (Write 0 to address R2)
22: ADDI R2, 2      -- R2 = R2 + 2 (Next multiple)
23: JMP 14          -- Jump back to LOOP_CHECK_2
24: NOP

-- FILTER 3 (Remove multiples of 3)
25: CLR R2          -- Clear R2
26: ADDI R2, 6      -- R2 = 6 (Start at 2*3)

-- LOOP_CHECK_3
27: MOV R7, R2      -- Temp check
28: OR R7, R8       -- Mask
29: SUB R7, R8      -- Compare
30: BLS +4          -- If valid, jump to ERASE (addr 34)
31: NOP
32: JMP 38          -- Else, jump to Next Filter (Filter 5)
33: NOP

-- ERASE_3
34: SW R2, R0       -- RAM[R2] = 0
35: ADDI R2, 3      -- R2 = R2 + 3
36: JMP 27          -- Jump back to LOOP_CHECK_3
37: NOP

-- FILTER 5 (Remove multiples of 5)
38: CLR R2          -- Clear R2
39: ADDI R2, 10     -- R2 = 10 (Start at 2*5)

-- LOOP_CHECK_5
40: MOV R7, R2      -- Temp check
41: OR R7, R8       -- Mask
42: SUB R7, R8      -- Compare
43: BLS +4          -- If valid, jump to ERASE (addr 47)
44: NOP
45: JMP 51          -- Else, jump to READ PHASE
46: NOP

-- ERASE_5
47: SW R2, R0       -- RAM[R2] = 0
48: ADDI R2, 5      -- R2 = R2 + 5
49: JMP 40          -- Jump back to LOOP_CHECK_5
50: NOP

-- PHASE 3: READ AND DISPLAY
51: CLR R1          -- Clear R1
52: ADDI R1, 2      -- R1 = 2 (Start reading from address 2)

-- LOOP_READ
53: LW R4, R1       -- Load RAM[R1] into R4
54: NOP             -- Wait for stabilization
55: MOV R6, R4      -- Move to R6 (Display Register)
56: ADDI R1, 1      -- Increment Read Address
57: MOV R7, R1      -- Check Loop Limit
58: OR R7, R8       -- Mask
59: SUB R7, R8      -- Compare
60: BLS -7          -- If R1 <= 31, loop back to LW (addr 53)
61: NOP

-- HALT
62: JMP 62          -- Infinite loop (End of program)


================================================================================
 PROGRAM 2: INSTRUCTION VALIDATION TEST
 Description: Tests all opcodes (ALU, Logic, Memory, Branches).
================================================================================

--- 1. ARITHMETIC INITIALIZATION
0:  CLR R1          -- Clear R1
1:  ADDI R1, 10     -- R1 = 10
2:  CLR R2          -- Clear R2
3:  ADDI R2, 5      -- R2 = 5
4:  CLR R3          -- Clear R3

-- 2. ADDITION TEST
5:  ADD R3, R1      -- R3 = 0 + 10 = 10
6:  ADD R3, R2      -- R3 = 10 + 5 = 15
7:  MOV R4, R3      -- R4 = 15 (Copy result to R4)

-- 3. SUBTRACTION & BRANCH LOWER SAME (BLS) TEST
8:  CLR R5          -- Clear R5
9:  SUB R5, R3      -- R5 = 0 - 15 = -15 (Triggers Borrow/Carry & Negative Flag)
10: BLS +2          -- Branch if Lower/Same (Offset +2 -> Target 12)
11: JMP 1           -- TRAP: If BLS fails, jump to 1 (Infinite error loop)

-- 4. MEMORY TEST (Store Word / Load Word)
12: CLR R5          -- Clear R5 (Target of BLS). Sets Address = 0.
13: SW R5, R4       -- RAM[R5] = R4 (Store 15 at Address 0)
14: CLR R6          -- Clear R6 (Destination for Load)
15: LW R6, R5       -- R6 = RAM[R5] (Load 15 from Address 0)

-- 5. LOGIC (OR) TEST
16: CLR R7          -- Clear R7
17: ADDI R7, 1      -- R7 = 1
18: OR R7, R6       -- R7 = 1 OR 15 = 15 (0001 OR 1111 = 1111)

-- 6. BRANCH POSITIVE (BPL) TEST
19: CLR R8          -- Clear R8
20: ADDI R8, 20     -- R8 = 20
21: SUB R8, R7      -- R8 = 20 - 15 = 5 (Result is Positive)
22: BPL +2          -- Branch if Positive (Offset +2 -> Target 24)
23: JMP 1           -- TRAP: If BPL fails, jump to 1

-- 7. SUCCESS / HALT
24: CLR R9          -- Clear R9 (Success Indicator reached)
25: JMP 25          -- HALT: Infinite loop at end of program

-- UNREACHABLE / PADDING
26: 1111...         -- Invalid Opcode (Padding)
27: ADDI...         -- Unreachable instruction